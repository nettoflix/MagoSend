#include "CHostControl.h"
#include "CTransferMonitor.h"
#include "CXmlTransferFinished.h"
#include <CallbackWorkerThread.h>
#include <QFileInfo>

QString CHostControl::magoMediaPath = "/mnt/AV1/Videos";
bool CHostControl::usarModalidadeLogica = false;
bool CHostControl::repeatSubFolderAsPrefix = false;
CHostControl::CHostControl(MainWindow* mainWindow) : mainWindow(mainWindow)
{
    CServiceUtils::KillAllTransferService();
    process1 = new QProcess();
    QThread::start();
    qDebug("CHostControl:: portasDisponiveis");
    setStartPort(CMagoDBCommandsThread::commands->getMagoDB()->getPortStart());
    for(int i=0; i<((endPort - startPort)/2); i++)
    {
        portasDisponiveis.append(startPort + (i*2)); //
        //qDebug("port: [%d]", portasDisponiveis.at(i));
    }
    // loadMagoSendIni();
    CHostControl::magoMediaPath = CMagoDBCommandsThread::commands->getMagoDB()->getMagoMediasPath();
    CHostControl::usarModalidadeLogica = CMagoDBCommandsThread::commands->getMagoDB()->shouldUseModalidadeLogica();
    CHostControl::repeatSubFolderAsPrefix = CMagoDBCommandsThread::commands->getMagoDB()->shouldUseModalidadePrefix();
    callbackThread = new CallbackWorkerThread(this);
    callbackThread->moveToThread(callbackThread);
    callbackThread->start();
    hostIndex =0;
}

int CHostControl::getHostIndex() const
{
    return hostIndex;
}

void CHostControl::incrementHostIndex()
{
    hostIndex = hostIndex + 1;
    if(getHostIndex() >= getHosts().size())
    {
        hostIndex = 0;
    }
}

void CHostControl::setStartPort(int value)
{
    startPort = value;
    endPort = value + 50;
}


QMutex &CHostControl::getHostsMutex()
{
    return hostsMutex;
}






MainWindow *CHostControl::getMainWindow() const
{
    return mainWindow;
}

Host *CHostControl::getHostByIp(QString ip)
{
    for(Host* host : getHosts())
    {
        if(host->getIp() == ip)
        {
            return host;
        }
    }
    return nullptr;
}

void CHostControl::registerIp(QString ip)
{
    QMutexLocker locker(&hostsMutex);
    for(int i=0; i<hosts.size(); i++)
    {
        if(ip == hosts.at(i)->getIp())
        {
            hosts.at(i)->setWasRemovedFromTableWidget(false); //se registerIp foi chamado mas o ip já existe no vetor de hosts
            return;											  //é porque o Host foi removido da interface mas ainda estava sendo usado pela lista de envios e agora foi adicionado na interface novamente
        }
    }
    int port = getNextAvailablePort();
    Host* host = new Host(this,ip, port);
    this->hosts.append(host);
    startTransferService(ip);


}

void CHostControl::markHostAsRemovedFromTable(QString ip)
{
    QMutexLocker locker(&hostsMutex);
    for (int i=0; i<hosts.size(); i++) {
        Host* host = hosts.at(i);
        if(host->getIp() == ip)
        {
            qDebug("CHostControl::markHostAsRemovedFromTable - ip [%s]", ip.toLatin1().data());
            host->setWasRemovedFromTableWidget(true);
        }
    }
}

void CHostControl::deleteHostIfItsNotBeingUsed()
{
    QMutexLocker locker(&hostsMutex);
    for (int i=0; i<hosts.size(); i++) {
        Host* host = hosts.at(i);

        if(host->getWasRemovedFromTableWidget() && !host->isBusy() && host->getCurrentUpload() == nullptr)
        {
            qDebug("hosts size: [%d]", hosts.size());
            qDebug("deleteHostIfItsNotBeingUsed - 2");
            qDebug("host: [%s]", host->getIp().toLatin1().data());
            freePort(host->getPort());

            this->hosts.replace(i, nullptr);
            this->hosts.remove(i);
            host->deleteLater();
            //delete host;
            CServiceUtils::KillTcpPort(host->getPort());
            //host->deleteLater();
            //delete host;

        }
    }
}
void CHostControl::startTransferServices()
{
    for (const Host* host : this->hosts) {
        QString ip = host->getIp();
        int port = host->getPort();
        qDebug("CHostControl::startTransferServices - 1");
        qDebug("CHostControl::startTransferServices - Starting service at ip: [%s] on port: [%d]", ip.toLatin1().data(), port);
        qDebug("host.process = [%d]", host->getProcess() == nullptr ? 1 : 0);
        CServiceUtils::StartTransferService(host->getProcess(),"", ip, QString::number(port)); //pra cada máquina que receber o video, eu precisarei de um processo do transfer // por isso vou precisar de uma porta diferente pra cada transfer

    }

}

void CHostControl::startTransferService(QString ip)
{
    //QMutexLocker locker(&hostsMutex);
    for (const Host* host : this->hosts) {
        //QMutexLocker locker(&hostsMutex);
        if(host->getIp() == ip)
        {
            qDebug() << "CHostControl::startTransferServic" << host->getIp() << ":" << QString::number(host->getPort()) << ".txt";
            CServiceUtils::StartTransferService(host->getProcess(),"/mnt/AV1/NettoDigisend", ip, QString::number(host->getPort()));
            connect(host->getProcess(), &QProcess::readyReadStandardOutput, [host]() mutable {
                QByteArray output = host->getProcess()->readAllStandardOutput();
                QFile file(host->getIp() + "-" + QString::number(host->getPort()) + ".txt");
                if (!file.open(QIODevice::Append | QIODevice::Text)) {
                    //qCritical() << "Could not open file for writing";
                    return;
                }
                QTextStream out(&file);
                out.seek(file.size());
                out << output;
                file.close();
            });
        }
    }

}

int CHostControl::getNextAvailablePort()
{
    if(!portasDisponiveis.isEmpty())
    {
        int port = portasDisponiveis.at(0);
        portasDisponiveis.removeFirst();
        return port;
    }
    qDebug("CHostControl::getNextAvailablePort - não há portas disponiveis!");
    return -1;
}

void CHostControl::freePort(int port)
{
    portasDisponiveis.append(port);
    QString antes;
    for(int porta : portasDisponiveis)
    {
        antes = antes + QString::number(porta) + ", ";
    }
    qDebug("freePort:: antes [%s]", antes.toLatin1().data());
    std::sort(portasDisponiveis.begin(), portasDisponiveis.end());
    QString depois;
    for(int porta : portasDisponiveis)
    {
        depois = depois + QString::number(porta) + " ";
    }
    qDebug("freePort:: depois [%s]", depois.toLatin1().data());
}


//função chamada pelo callback do transferlocal avisando que o video foi enviado com sucesso (ou cancelado)
void CHostControl::markVideoAsSent(QString fileName, QString hostIp)
{
    qDebug("CHostControl::marVideoAsSent, ip [%s] para o video [%s]", hostIp.toLatin1().data(), fileName.toLatin1().data());
    QMetaObject::invokeMethod(callbackThread, "enqueue",
                                  Qt::QueuedConnection,
                                  Q_ARG(QString, fileName),
                                  Q_ARG(QString, hostIp));
    //incrementHostIndex();
    //QThread::msleep(10000);

}


const QVector<Host*> &CHostControl::getHosts() const
{
    return this->hosts;
}

void CHostControl::run()
{
    //inicia o servidor XMLRpc deste servico...
    xmlRpcServer = new XmlRpc::XmlRpcServer();
    xmlRpcServer->bindAndListen(2000);
    xmlRpcServer->enableIntrospection(true);
    CXmlTransferFinished xmlTransferFinished(this);

    while(true)
    {
        xmlRpcServer->work(10000);
    }

    xmlRpcServer->close();
    delete xmlRpcServer;
}

XmlRpc::XmlRpcServer* CHostControl::getXmlRpcServer() const
{
    return xmlRpcServer;
}
void CHostControl::readCallbackData()
{
    QSharedMemory sharedMemory(SHARED_MEMORY_KEY);
    QSystemSemaphore semaphore(SEMAPHORE_KEY, 0, QSystemSemaphore::Open);
    QSystemSemaphore mutex(MUTEX_KEY, 1, QSystemSemaphore::Open);

    while (true)  // Continuously process new messages
    {
        semaphore.acquire();  // Wait for new data

        mutex.acquire();  // Lock access

        sharedMemory.lock();

        QByteArray data(static_cast<char*>(sharedMemory.data()), sharedMemory.size());
        QBuffer buffer(&data);
        buffer.open(QIODevice::ReadOnly);
        QDataStream stream(&buffer);

        QString fileName, ip;
        stream >> fileName >> ip;  // Deserialize

        sharedMemory.unlock();

        mutex.release();  // Unlock access

        qDebug() << "Processing callback: File:" << fileName << " IP:" << ip;

        // Simulate processing time
        QThread::sleep(2);
    }
}




