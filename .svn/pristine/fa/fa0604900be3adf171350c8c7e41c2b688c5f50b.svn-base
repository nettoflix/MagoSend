#include "COpenedWindows.h"
#include "CServiceUtils.h"

#include <QDir>
#include <QRegExpValidator>




CServiceUtils::CServiceUtils()
{

}
void CServiceUtils::KillAllTransferService()
{
#ifdef _WIN32
    KillAllServicesWithThisname("4SMagoTransferServer.exe");
#else
    KillAllServicesWithThisname("4SMagoTransferServer");

    //por garantia, caso o transfer server esteja preso por motivos de problemas com rede,
    //mandaremos o linux matar quem controla as portas do TransferServer, no caso, ele mesmo...
    CServiceUtils::KillTcpPort(MAGO_TRANSFER_SERVER_PORT_1);
    CServiceUtils::KillTcpPort(MAGO_TRANSFER_SERVER_PORT_2);
#endif
}
void CServiceUtils::KillAllServicesWithThisname(QString name)
{
#ifdef WIN32
    QStringList appIds = COpenedWindows::getAllOpenedWindowsIDThathStarWith(name.toLatin1().data());
    for (int i = 0; i < appIds.size(); i++)
    {
        QString killCommand = "taskkill /PID " + appIds[i] + " /f";
      //  qDebug("CServiceUtils::killAllInputServices() : killcommand [%s]", killCommand.toLatin1().data());

        QStringList params;
        params << "/c" << killCommand;
        QProcess* myProcess = new QProcess();
        myProcess->start("cmd.exe", params);
        myProcess->waitForFinished(INT_MAX);
    }
#else
    {
        QString killCommand = "pkill";
        QStringList params;
        params << "-9";
        params << "-f";
        params << name;
        QProcess* myProcess = new QProcess();
        myProcess->start(killCommand, params);
        myProcess->waitForFinished(INT_MAX);
    }
#endif
}
void CServiceUtils::StartTransferService(QProcess* process1, QString localPath, QString remoteIp, QString port)
{
    QProcess* process;
    if(process1 == nullptr)
    {
        process = new QProcess();
    }
    else
    {
        process = process1;
    }

    QStringList args;
    args.append(localPath);
    args.append(remoteIp);
    args.append(port);
    args.append("false"); //shouldLoadList = false

#ifdef _WIN32
    QString appName(QApplication::instance()->applicationDirPath() + "/4SMagoTransferServer.exe");
#else
    QString appName(QApplication::instance()->applicationDirPath() + "/4SMagoTransferServer");
#endif

    if (QFile::exists(appName))
    {
        //process->setStandardOutputFile(QProcess::nullDevice());
        //process->setStandardErrorFile(QProcess::nullDevice());
        //process->setStandardInputFile(QProcess::nullDevice());
        process->start(appName, args);
        if(process->waitForStarted())
        {
            qDebug("Processo do TransferServer não iniciou");
        }
        else
        {
            qDebug("Processo do TransferServer iniciado");
        }

    }

}
bool CServiceUtils::KillTcpPort(int portId)
{
#ifdef __linux
    QString killCommand = "fuser";
    QStringList params;
    params << "-k";
    params << QString::number(portId) + "/tcp";
    QProcess* myProcess = new QProcess();
    myProcess->start(killCommand, params);
    return myProcess->waitForFinished(INT_MAX);
#else
    QString netstatCommand = "netstat";
    QStringList netstatParams;
    netstatParams << "-ano"; // Lista todas conexoes e seus PID

    QProcess netstatProcess;
    netstatProcess.start(netstatCommand, netstatParams);
    if (!netstatProcess.waitForFinished() || netstatProcess.exitStatus() != QProcess::NormalExit)
        return false;

    QString output = netstatProcess.readAllStandardOutput();
    QString portString = QString(":%1").arg(portId);
    QString pid;

    // Acha o PID correspondente a porte
    foreach (const QString &line, output.split('\n')) {
        if (line.contains(portString)) {
            QStringList tokens = line.split(QRegExp("\\s+"), QString::SkipEmptyParts); //divide o output do netstat em colunas (divido por espaços em branco)
            if (tokens.size() >= 5) {
                pid = tokens.last(); //o PID eh a ultima coluna
                break;
            }
        }
    }

    if (pid.isEmpty()) {
        qDebug( "Nenhum processo encontrado usando a porta [%d]", portId);
        return false;
    }

    // Matar o processo
    QString taskkillCommand = "taskkill";
    QStringList taskkillParams;
    taskkillParams << "/PID" << pid << "/F";

    QProcess taskkillProcess;
    taskkillProcess.start(taskkillCommand, taskkillParams);
    if (!taskkillProcess.waitForFinished() || taskkillProcess.exitStatus() != QProcess::NormalExit) {
        qDebug( "impossivel matar o processo PID [%s]", pid.toLatin1().data());
        return false;
    }

    return true;
#endif
}



bool CServiceUtils::isValidIPv4format(QString ip)
{
    // Expressão regular para endereços IPV4 válidos
    QRegExp regExp("^((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])(\.(?!$)|$)){4}$");
    QRegExpValidator validator(regExp);
    int pos =0;
    QValidator::State state = validator.validate(ip,pos);
    if(state == QValidator::Acceptable)
    {
        return true;
    }
    else
    {
        return false;
    }
}
bool CServiceUtils::isValidFilename(QString filename) {
    QRegularExpression invalidPattern("[/\\\\:*?\"<>|\\^%&;\\[\\]{}\`'~$+,]");//caracteres especiais
    int countDot = filename.count('.');
    if(countDot > 1) return false; //nao aceita nomes de arquivos com pontos (o unico ponto permitido é do da extensao)
    return !filename.contains(invalidPattern);
}
bool CServiceUtils::isValidIDname(QString filename) {
    QRegularExpression invalidPattern("[/\\\\:*?\"<>|\\^%&;\\[\\]{}\`'~$+,]");//caracteres especiais
    int countDot = filename.count('.'); //tambem nao aceita pontos
    if(countDot > 0) return false;
    return !filename.contains(invalidPattern);
}
QString CServiceUtils::convertWindowsPathToLinux(const QString& windowsPath) {
    QString linuxCompatiblePath = windowsPath;
    linuxCompatiblePath.replace('/', '\\');
    return linuxCompatiblePath;
}
