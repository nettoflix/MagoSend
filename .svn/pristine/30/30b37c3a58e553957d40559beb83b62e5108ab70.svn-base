#ifndef CHOSTCONTROL_H
#define CHOSTCONTROL_H

#include <QVector>
#include "CServiceUtils.h"
#include "CUploadServiceClient.h"
#include <QProcess>
#include <QDebug>
#include <XmlRpc.h>
#include <QThread>
#include <QFile>
#include "CTransferMonitor.h"
#include "Host.h"
#include "mainwindow.h"
#include <QQueue>
//#include <QTcpServer>

class MainWindow;
class CTransferMonitor;
class CallbackWorkerThread;
//esse cara gerencia as portas, os hosts e principalmente escuta o callback do transfer que avisa que o envio foi finalizado
class CHostControl : public QThread
{

public:

	CHostControl(MainWindow* mainWindow);


private:
    CallbackWorkerThread* callbackThread;
	MainWindow* mainWindow;
	XmlRpc::XmlRpcServer* xmlRpcServer;
	QVector<Host*> hosts;
	QMutex hostsMutex;


	//
	QVector<int> portasDisponiveis;

	int controlPort = 1700;
	QProcess* process1;
    int hostIndex;
	//functions
   // void loadMagoSendIni();
public:
    quint16 startPort = 20000;
    quint16 endPort = 20050;
    static QString magoMediaPath;
    static bool repeatSubFolderAsPrefix;
    static bool usarModalidadeLogica;
    void setStartPort(int value);
	void run();
	void registerIp(QString ip);
	void markHostAsRemovedFromTable(QString ip);
	void deleteHostIfItsNotBeingUsed();
	void startTransferServices();
	void startTransferService(QString ip);
	int getNextAvailablePort();
	void freePort(int port);
	void markVideoAsSent(QString fileName, QString hostIp);


	const QVector<Host*> &getHosts() const;
	XmlRpc::XmlRpcServer* getXmlRpcServer() const;
	MainWindow *getMainWindow() const;
	Host* getHostByIp(QString ip);
    void readCallbackData();




	QMutex &getHostsMutex();
    int getHostIndex() const;
    void incrementHostIndex();
};

#endif // CHostControl_H
