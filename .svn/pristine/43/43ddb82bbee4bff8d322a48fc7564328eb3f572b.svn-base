#include "CHostControl.h"
#include "CTransferMonitor.h"
#include "CXmlTransferFinished.h"

#include <QFileInfo>
CHostControl::CHostControl(MainWindow* mainWindow) : mainWindow(mainWindow)
{
    CServiceUtils::KillAllTransferService();
    process1 = new QProcess();
    QThread::start();
    qDebug("CHostControl:: portasDisponiveis");
    for(int i=0; i<((endPort - startPort)/2); i++)
    {
        portasDisponiveis.append(startPort + (i*2)); //
        //qDebug("port: [%d]", portasDisponiveis.at(i));
    }

}

QMutex &CHostControl::getHostsMutex()
{
    return hostsMutex;
}






MainWindow *CHostControl::getMainWindow() const
{
    return mainWindow;
}

Host *CHostControl::getHostByIp(QString ip)
{
    for(Host* host : getHosts())
    {
        if(host->getIp() == ip)
        {
            return host;
        }
    }
    return nullptr;
}

void CHostControl::registerIp(QString ip)
{
    QMutexLocker locker(&hostsMutex);
    for(int i=0; i<hosts.size(); i++)
    {
        if(ip == hosts.at(i)->getIp())
        {
            hosts.at(i)->setWasRemovedFromTableWidget(false); //se registerIp foi chamado mas o ip já existe no vetor de hosts
            return;											  //é porque o Host foi removido da interface mas ainda estava sendo usado pela lista de envios e agora foi adicionado na interface novamente
        }
    }
    int port = getNextAvailablePort();
    Host* host = new Host(this,ip, port);
    this->hosts.append(host);
    startTransferService(ip);


}

void CHostControl::markHostAsRemovedFromTable(QString ip)
{
    QMutexLocker locker(&hostsMutex);
    for (int i=0; i<hosts.size(); i++) {
        Host* host = hosts.at(i);
        if(host->getIp() == ip)
        {
            qDebug("CHostControl::markHostAsRemovedFromTable - ip [%s]", ip.toLatin1().data());
            host->setWasRemovedFromTableWidget(true);
        }
    }
}

void CHostControl::deleteHostIfItsNotBeingUsed()
{
    QMutexLocker locker(&hostsMutex);
    for (int i=0; i<hosts.size(); i++) {
		Host* host = hosts.at(i);

        if(host->getWasRemovedFromTableWidget() && !host->isBusy() && host->getCurrentUpload() == nullptr)
        {
            qDebug("hosts size: [%d]", hosts.size());
            qDebug("deleteHostIfItsNotBeingUsed - 2");
            qDebug("host: [%s]", host->getIp().toLatin1().data());
            freePort(host->getPort());

            this->hosts.replace(i, nullptr);
            this->hosts.remove(i);
            delete host;
             CServiceUtils::KillTcpPort(host->getPort());
            //host->deleteLater();
            //delete host;

        }
    }
}
void CHostControl::startTransferServices()
{
    for (const Host* host : this->hosts) {
        QString ip = host->getIp();
        int port = host->getPort();
        qDebug("CHostControl::startTransferServices - 1");
        qDebug("CHostControl::startTransferServices - Starting service at ip: [%s] on port: [%d]", ip.toLatin1().data(), port);
        qDebug("host.process = [%d]", host->getProcess() == nullptr ? 1 : 0);
        CServiceUtils::StartTransferService(host->getProcess(),"", ip, QString::number(port)); //pra cada máquina que receber o video, eu precisarei de um processo do transfer // por isso vou precisar de uma porta diferente pra cada transfer

    }

}

void CHostControl::startTransferService(QString ip)
{
    //QMutexLocker locker(&hostsMutex);
    for (const Host* host : this->hosts) {
        //QMutexLocker locker(&hostsMutex);
        if(host->getIp() == ip)
        {
            qDebug() << "CHostControl::startTransferServic" << host->getIp() << ":" << QString::number(host->getPort()) << ".txt";
            CServiceUtils::StartTransferService(host->getProcess(),"/mnt/AV1/NettoDigisend", ip, QString::number(host->getPort()));
            connect(host->getProcess(), &QProcess::readyReadStandardOutput, [host]() mutable {
                QByteArray output = host->getProcess()->readAllStandardOutput();
                QFile file(host->getIp() + "-" + QString::number(host->getPort()) + ".txt");
                if (!file.open(QIODevice::Append | QIODevice::Text)) {
                    qCritical() << "Could not open file for writing";
                    return;
                }
                QTextStream out(&file);
                out.seek(file.size());
                out << output;
                file.close();
            });
        }
    }

}

int CHostControl::getNextAvailablePort()
{
    if(!portasDisponiveis.isEmpty())
    {
        int port = portasDisponiveis.at(0);
        portasDisponiveis.removeFirst();
        return port;
    }
    qDebug("CHostControl::getNextAvailablePort - não há portas disponiveis!");
    return -1;
}

void CHostControl::freePort(int port)
{
    portasDisponiveis.append(port);
    QString antes;
    for(int porta : portasDisponiveis)
    {
        antes = antes + QString::number(porta) + ", ";
    }
    qDebug("freePort:: antes [%s]", antes.toLatin1().data());
    std::sort(portasDisponiveis.begin(), portasDisponiveis.end());
    QString depois;
    for(int porta : portasDisponiveis)
    {
        depois = depois + QString::number(porta) + " ";
    }
    qDebug("freePort:: depois [%s]", depois.toLatin1().data());
}


//função chamada pelo callback do transferlocal avisando que o video foi enviado com sucesso (ou cancelado)
void CHostControl::markVideoAsSent(QString fileName, QString hostIp)
{
    //	qDebug("CHostControl::marVideoAsSent, ip [%s]", hostIp.toLatin1().data());
    QDateTime now = QDateTime::currentDateTime();
    QString nowStr = now.toString("yyyy-MM-dd hh:mm:ss");
    QMutexLocker hostsLocker(&hostsMutex);
	qDebug("CHostControl::marVideoAsSent - 1");
    for(Host* host : this->getHosts())
    {
        if(host->getIp() == hostIp)
        {
            host->setBusy(false);
            host->setCurrentUpload(nullptr);
        }
    }
    hostsLocker.unlock();
    QMutexLocker queueLocker(&getMainWindow()->getTransferMonitor()->getQueueMutex());
    int count = 0;
    for(VideoFileInfo* videoInfo : getMainWindow()->getTransferMonitor()->getCurrentQueue())
    {
        count++;
        QFileInfo fileInfo(videoInfo->getFilename());
        QString filepath = fileInfo.filePath();
        QString videoInfo_fileName = fileInfo.fileName();
        QString numero = videoInfo->getId();
        QString titulo = videoInfo->getTitulo();
        QString modalidade = videoInfo->getModalidade();
        QString baseName = videoInfo->getBaseName();
        QString duration = videoInfo->getDuration();
        bool doesFilenameMatch = false;
#ifdef __WIN32
        QByteArray videoFileNameConverted =videoInfo_fileName.toUtf8().data();
        QByteArray filenameCalledbackConverted = fileName.toLatin1().data();
        if(videoFileNameConverted == filenameCalledbackConverted) doesFilenameMatch = true;
#else
        if(videoInfo_fileName == fileName) doesFilenameMatch = true;
#endif


        if(doesFilenameMatch && videoInfo->getIp() == hostIp)
        {
            //	qDebug("CHostControl::markVideoAsSent - videoInfo_fileName == fileName ");
            videoInfo->setIsActiveUpload(false);
            /* Mesmo quando o video é cancelado pelo usuário, o transfer executa o callback que chama essa funcao "markVideoAsSent"
            por isso, precisamos checar se o video não foi cancelado antes de marcar ele como "enviado" */
            if(videoInfo->getStatus() != CVideoStatus::CANCELLED) //
            {

                videoInfo->setStatus(CVideoStatus::SENT);
                //qDebug("nowStr: [%s]", nowStr.toLatin1().data());
                //cadastra no banco de dados da máquina local (magosenddb)
#ifdef __linux
                CMagoDBCommandsThread::commands->queuedAddHistoricoMagoSend(numero.toLatin1(),titulo.toLatin1(), filepath.toLatin1(),modalidade,
                                                                            duration, hostIp,videoInfo->getStatusString(), nowStr, getMainWindow()->getUsuario());
#else
                CMagoDBCommandsThread::commands->queuedAddHistoricoMagoSend(numero,titulo, filepath,modalidade,
                                                                            duration, hostIp,videoInfo->getStatusString(), nowStr, getMainWindow()->getUsuario());
#endif
                //cadastra o evento no banco de dados do Mago Host

                MagoDB* magodb = new MagoDB(hostIp.toLatin1().data(), false);
                QString magosendIniFileName = QApplication::applicationDirPath() + "/MagoSend.ini";
                QSettings settings(magosendIniFileName, QSettings::IniFormat);
                QString magoMediaPath = settings.value("magoMediaPath").toString();
                QString path = magoMediaPath + "/"+ baseName;
                //	qDebug("CHostControl::markVideoAsSent -  gonna save in db the path: [%s]", path.toLatin1().data());

#ifdef __linux
                if(magodb->EventExistsByNumber(numero.toLatin1().data()))
                {
                    //	qDebug("EventExistsByNumber");
                    magodb->UpdateEvent(numero.toLatin1().data(), path.toLatin1().data(), path.toLatin1().data(), titulo.toLatin1().data(),0,0,0,0,"","",0,modalidade.toUtf8().data());
                }
                else
                {

                    //	qDebug("magodb->addEvent path: [%s]", path.toLatin1().data());
                    magodb->AddEvent(numero.toLatin1().data(),path.toLatin1().data(), titulo.toLatin1().data(), 0, 0, 0, 0, "", "", 0,modalidade.toUtf8().data());
                }
#else
                if(magodb->EventExistsByNumber(numero.toUtf8().data()))
                {
                    //	qDebug("EventExistsByNumber");
                    magodb->UpdateEvent(numero.toUtf8().data(), numero.toUtf8().data(), path.toUtf8().data(), titulo.toUtf8().data(),0,0,0,0,"","",0,modalidade.toUtf8().data());
                }
                else
                {

                    //	qDebug("magodb->addEvent path: [%s]", path.toLatin1().data());
                    magodb->AddEvent(numero.toUtf8().data(),path.toUtf8().data(), titulo.toUtf8().data(), 0, 0, 0, 0, "", "", 0,modalidade.toUtf8().data());
                }
#endif
                delete magodb;
            }
            break;
        }
    }
}


const QVector<Host*> &CHostControl::getHosts() const
{
    return this->hosts;
}

void CHostControl::run()
{
    //inicia o servidor XMLRpc deste servico...
    xmlRpcServer = new XmlRpc::XmlRpcServer();
    xmlRpcServer->bindAndListen(2000);
    xmlRpcServer->enableIntrospection(true);
    CXmlTransferFinished xmlTransferFinished(this);

    while(true)
    {
        xmlRpcServer->work(10000);
    }

    xmlRpcServer->close();
    delete xmlRpcServer;
}

XmlRpc::XmlRpcServer* CHostControl::getXmlRpcServer() const
{
    return xmlRpcServer;
}





