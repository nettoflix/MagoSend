/*
 * CMagoDBCommandsThread.cpp
 *
 *  Created on: 30 de nov de 2018
 *      Author: helmuth
 */

#include <QFileInfo>
#include <QVariant>
#include <QSqlQuery>

#include "CMagoDBCommandsThread.h"
#include "CUtil.h"
#include <QDate>

#include <CVideoFileInformation.h>
#include "CMainWindow.h"
#include <CMediaLibraryItem.h>

CMagoDBCommandsThread* CMagoDBCommandsThread::commands = nullptr;

QMutex CMagoDBCommandsThread::mutex;
QStringList CMagoDBCommandsThread::connectionsNames;

CMagoDBCommandsThread::CMagoDBCommandsThread() :
	QThread()
{
	CMagoDBCommandsThread::commands = this;

	magoDB = nullptr;
	worker = nullptr;

	QThread::start();

	waiter.wait();

}

CMagoDBCommandsThread::~CMagoDBCommandsThread()
{
	exit();
	wait();

	CMagoDBCommandsThread::commands = nullptr;
}

void CMagoDBCommandsThread::run()
{
	//isso faz criar um DB com uma conexao com nome extra para nao
	//dar rolo com a conexao principal...

	if (CMainWindow::mainWindow->config.isMagoRemoto)
	{
		qDebug("CMagoDBCommandsThread::run - MAGO REMOTO - ip = [%s]", CMainWindow::mainWindow->config.magoServerIP.toLatin1().data());
		magoDB = CreateDB(CMainWindow::mainWindow->config.magoServerIP.toLatin1().data(), true);
	}
	else
	{
		qDebug("CMagoDBCommandsThread::run - NAO É MAGO REMOTO - ip será local");
		magoDB =  CreateDB("127.0.0.1", true);
	}

	//magoDB =  CreateDB("127.0.0.1", true);

	worker = new CMagoDBCommandsThreadWorker(this);

	waiter.wake(1);

	exec();

	delete worker;
	worker = nullptr;
}

/*!
 * Faz uma pesquisa via thread na tabela de eventos, ordenada pelo campo "orderBy", e assim que estiver pronta,
 * envia os resultados chamando o o metodo "methodName" de "object"...
 * ATENCAO: esse metodo NAO bloqueia a thread principal...
 * @param field
 * @param value
 * @param orderBy
 * @param object
 * @param methodName
 */
void CMagoDBCommandsThread::queuedLoadAllEventsOrderByWithValueEqual(QString field, QString value, QString orderBy, QObject* object, QString methodName)
{
	QMetaObject::invokeMethod(worker, "queuedLoadAllEventsOrderByWithValueEqual", Qt::QueuedConnection, Q_ARG(QString, field), Q_ARG(QString, value), Q_ARG(QString, orderBy), Q_ARG(QObject*, object), Q_ARG(QString, methodName));
}

void CMagoDBCommandsThread::queuedLoadAllProgramsOrderByWithValueEqual(QString field, QString value, QString orderBy, QObject* object, QString methodName)
{
	QMetaObject::invokeMethod(worker, "queuedLoadAllProgramsOrderByWithValueEqual", Qt::QueuedConnection, Q_ARG(QString, field), Q_ARG(QString, value), Q_ARG(QString, orderBy), Q_ARG(QObject*, object), Q_ARG(QString, methodName));
}

/*!
 * atualiza todos os eventos do Banco de dados que tenham esse "Path" com novos frameIn e frameOut...
 * @param path
 * @param frameIn
 * @param frameOut
 */
void CMagoDBCommandsThread::queuedUpdateAllEventsWithNewVideoInformationByPath(QString path, int frameIn, int frameOut)
{
	qDebug("CMagoDBCommandsThread::queuedUpdateAllEventsWithNewVideoInformationByPath() - IN");

	QMetaObject::invokeMethod(worker, "queuedUpdateAllEventsWithNewVideoInformationByPath", Qt::QueuedConnection, Q_ARG(QString, path), Q_ARG(int, frameIn), Q_ARG(int, frameOut));

	qDebug("CMagoDBCommandsThread::queuedUpdateAllEventsWithNewVideoInformationByPath() - OUT");
}

/*!
 * atualiza todos os eventos do Banco de dados que tenham esse "Path" para sem Path
 */

void CMagoDBCommandsThread::queuedSetAllEventsWithNullPath(QString path)
{
	qDebug("CMagoDBCommandsThread::queuedSetAllEventsWithNullPath() - IN");

	QMetaObject::invokeMethod(worker, "queuedSetAllEventsWithNullPath", Qt::QueuedConnection, Q_ARG(QString, path));

	qDebug("CMagoDBCommandsThread::queuedSetAllEventsWithNullPath() - OUT");
}

/*!
 * Faz uma pesquisa via thread PRINCIPAL na tabela de eventos, ordenada pelo campo "orderBy".
 * ATENCAO: esse metodo bloqueia a thread principal...
 * @param field
 * @param value
 * @param orderBy
 * @return
 */
CMagoDBEventCollection CMagoDBCommandsThread::loadAllEventsOrderByWithValueEqual(QString field, QString value, QString orderBy)
{
	CMagoDBEventCollection events;

	QMetaObject::invokeMethod(worker, "loadAllEventsOrderByWithValueEqual", Qt::BlockingQueuedConnection, Q_ARG(QString, field), Q_ARG(QString, value), Q_ARG(QString, orderBy), Q_ARG(void*, (void* )&events));

	return events;
}

void CMagoDBCommandsThread::queuedAddHistorico(QString ticket, QString numero, QString titulo, int duracaoreal, QString veiculacao, int roteiro, QDateTime data, QDateTime entrada, QDateTime saida, int posicaomesa, QString hPrevisto, QString crit1)
{
	QString sData = data.toString("yyyy-MM-dd hh:mm:ss");
	QString sEntrada = entrada.toString("yyyy-MM-dd hh:mm:ss.zzz");
	QString sSaida = saida.toString("yyyy-MM-dd hh:mm:ss.zzz");

	//vai estourar limite, ultimos 3 mandar como list (outra hora arrumo pra mandar tudo como uma lista unica
	QStringList list;
	list.push_back(QString::number(posicaomesa));
	list.push_back(hPrevisto);
	list.push_back(crit1);

	//QMetaObject::invokeMethod(worker, "queuedAddHistorico", Qt::QueuedConnection, Q_ARG(QString, ticket), Q_ARG(QString, numero), Q_ARG(QString, titulo), Q_ARG(int, duracaoreal), Q_ARG(QString, veiculacao), Q_ARG(int, roteiro), Q_ARG(QString, sData), Q_ARG(QString, sEntrada), Q_ARG(QString, sSaida), Q_ARG(int, posicaomesa), Q_ARG(QString, hPrevisto), Q_ARG(QString, crit1));
	QMetaObject::invokeMethod(worker, "queuedAddHistorico", Qt::QueuedConnection, Q_ARG(QString, ticket), Q_ARG(QString, numero), Q_ARG(QString, titulo), Q_ARG(int, duracaoreal), Q_ARG(QString, veiculacao), Q_ARG(int, roteiro), Q_ARG(QString, sData), Q_ARG(QString, sEntrada), Q_ARG(QString, sSaida), Q_ARG(QStringList, list));
}

void CMagoDBCommandsThread::queuedChangeHistoricoSaida(QString ticket, int roteiro, QDateTime saida)
{
	QString sSaida = saida.toString("yyyy-MM-dd hh:mm:ss.zzz");

	QMetaObject::invokeMethod(worker, "queuedChangeHistoricoSaida", Qt::QueuedConnection, Q_ARG(QString, ticket), Q_ARG(int, roteiro), Q_ARG(QString, sSaida));
}

void CMagoDBCommandsThread::queuedCreateEventByPathIfDosentExist(QString path, QObject* object, QString methodName, int finishedInicilization)
{
	QMetaObject::invokeMethod(worker, "queuedCreateEventByPathIfDosentExist", Qt::QueuedConnection, Q_ARG(QString, path), Q_ARG(QObject*, object), Q_ARG(QString, methodName), Q_ARG(int, finishedInicilization));
}

CMagoDBCommandsThreadWorker::CMagoDBCommandsThreadWorker(CMagoDBCommandsThread* t) :
	QObject()
{
	thread = t;

	myOwnDatabaseConnection = thread->getRandomConnection();
	qDebug("CMagoDBCommandsThreadWorker dbconnectionname [%s]", myOwnDatabaseConnection.connectionName().toLatin1().data());
}

CMagoDBCommandsThreadWorker::~CMagoDBCommandsThreadWorker()
{
	myOwnDatabaseConnection.close();
}

void CMagoDBCommandsThreadWorker::queuedLoadAllEventsOrderByWithValueEqual(QString field, QString value, QString orderBy, QObject* object, QString methodName)
{

	QString dbConnectionName;
	{
		QSqlDatabase connection = CMagoDBCommandsThread::commands->getRandomConnection();
		dbConnectionName = connection.connectionName();

		QSqlQuery* query = (QSqlQuery*) thread->getMagoDB()->loadAllEventsOrderByWithValueEqual(orderBy.toLatin1().data(), field.toLatin1().data(), value.toLatin1().data(), &connection);
		//QSqlQuery* query = (QSqlQuery*) thread->getMagoDB()->loadAllEventsOrderByWithValueEqual(orderBy.toLatin1().data(), field.toLatin1().data(), value.toLatin1().data(), &myOwnDatabaseConnection);


		if (query != nullptr)
		{
			CMagoDBEventCollection* events = new CMagoDBEventCollection();

			events->loadFromQuery(query);

			delete query;

			QMetaObject::invokeMethod(object, methodName.toLatin1().data(), Qt::QueuedConnection, Q_ARG(void*, events));
		}
	}
	QSqlDatabase::removeDatabase(dbConnectionName);

}

void CMagoDBCommandsThreadWorker::loadAllEventsOrderByWithValueEqual(QString field, QString value, QString orderBy, void* result)
{
	QString dbConnectionName;
	{
		QSqlDatabase connection = CMagoDBCommandsThread::commands->getRandomConnection();
		dbConnectionName = connection.connectionName();


		CMagoDBEventCollection* events = (CMagoDBEventCollection*) result;

		QSqlQuery* query = (QSqlQuery*) thread->getMagoDB()->loadAllEventsOrderByWithValueEqual(orderBy.toLatin1().data(), field.toLatin1().data(), value.toLatin1().data(), &connection);
		//QSqlQuery* query = (QSqlQuery*) thread->getMagoDB()->loadAllEventsOrderByWithValueEqual(orderBy.toLatin1().data(), field.toLatin1().data(), value.toLatin1().data(), &myOwnDatabaseConnection);
		if (query != nullptr)
		{
			events->loadFromQuery(query);

			delete query;
		}
	}
	QSqlDatabase::removeDatabase(dbConnectionName);
}

//void CMagoDBCommandsThreadWorker::queuedAddHistorico(QString ticket, QString numero, QString titulo, int duracaoreal, QString veiculacao, int roteiro, QString data, QString entrada, QString saida, int posicaomesa, QString hPrevisto, QString crit1)
void CMagoDBCommandsThreadWorker::queuedAddHistorico(QString ticket, QString numero, QString titulo, int duracaoreal, QString veiculacao, int roteiro, QString data, QString entrada, QString saida, QStringList list)
{
	QString fullTicket = ticket + "_" + QString::number(roteiro);

	int histoId = -1;

	int posicaomesa = -1;
	QString posMesa = "";
	QString hPrevisto = "";
	QString crit1 = "";

	for (unsigned int i = 0; i < list.size(); i++)
	{
		switch (i) {
		case 0:
			posMesa = list[i];
			posicaomesa = posMesa.toInt();
			break;
		case 1:
			hPrevisto = list[i];
			break;
		case 2:
			crit1 = list[i];
			break;
		default:
			break;
		}
	}

	QString dbConnectionName;
	{
		QSqlDatabase connection = thread->getRandomConnection();

		dbConnectionName = connection.connectionName();

		try
		{

			 histoId = thread->getMagoDB()->AddHistorico(
							  numero.toLatin1().data(),
							  titulo.toLatin1().data(),
							  duracaoreal,
							  veiculacao.toLatin1().data(),
							  roteiro,
							  data.toLatin1().data(),
							  entrada.toLatin1().data(),
							  saida.toLatin1().data(),
							  posicaomesa,
							  hPrevisto.toLatin1().data(),
							  crit1.toLatin1().data(),
							  &connection
						  );
		}
		catch(...)
		{
			qDebug("CMagoDBCommandsThreadWorker::queuedAddHistorico - Erro exception");
		}

		connection.close();
	}

	//thread->deleteRandomConnection(&connection);

	QSqlDatabase::removeDatabase(dbConnectionName);


	historyIds.insert(fullTicket, histoId);
}



